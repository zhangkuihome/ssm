1、mybatis中的连接池以及事务控制			原理部分了解，应用部分会用
	mybatis中连接池使用及分析
	mybatis事务控制的分析
2、mybatis基于XML配置的动态SQL语句使用		会用即可
	mappers配置文件中的几个标签：
		<if>
		<where>
		<foreach>
		<sql>
3、mybatis中的多表操作				掌握应用
	一对多
	一对一（？）
	多对多
--------------------------------------------------------------------------------
1、连接池：
JNDI :需要交给tomcat管理或当前工程war

Map
key:固定字符串/连接池名称
value:连接池
	我们在实际开发中都会使用连接池。
	因为它可以减少我们获取连接所消耗的时间。
2、mybatis中的连接池
	mybatis连接池提供了3种方式的配置：
		配置的位置：
			主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。
		type属性的取值：
			POOLED	 采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现
			UNPOOLED 采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。
			JNDI	 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。
				 注意：如果不是web或者maven的war工程，是不能使用的。
				 我们课程中使用的是tomcat服务器，采用连接池就是dbcp连接池。
3、mybatis中的事务
	什么是事务
		事务就是并发控制的单位，是用户定义的一个操作序列
	事务的四大特性ACID
		A：原子性（Atomicity）
			事务中的操作要么都不做，要么就全做。
		C：一致性（Consistency）
			事务执行的结果必须是从数据库从一个一致性状态转换到另一个一致性状态。
		I：隔离性（Isolation）
			一个事务的执行不能被其他事务干扰
		D：持久性（Durability）
			一个事务一旦提交，它对数据库中数据的改变就应该是永久性的
--------------------- 
	不考虑隔离性会产生的3个问题
		脏读:是指一个事务读取了另一个事务没有提交的数据
		不可重复读:在一个事务内读取表中的某一行数据，多次读取结果不相同
			不可重复读和脏读的区别，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已经提交的数据。
		虚读:是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。
			不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表
	解决办法：四种隔离级别

	它是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚
4、mybatis中的多表查询
	表之间的关系有几种：
		一对多
		多对一
		一对一
		多对多
	举例：
		用户和订单就是一对多
		订单和用户就是多对一
			一个用户可以下多个订单
			多个订单属于同一个用户

		人和身份证号就是一对一
			一个人只能有一个身份证号
			一个身份证号只能属于一个人

		老师和学生之间就是多对多
			一个学生可以被多个老师教过
			一个老师可以交多个学生
	特例：
		如果拿出每一个订单，他都只能属于一个用户。
		所以Mybatis就把多对一看成了一对一。
	
	mybatis中的多表查询：
	一对一:
	面向对象编写表与表之间的关系:
		1:1在外键实体类加入主键实体类的引用(定义一个主键实体类对象)
		<association roperty="实体类对象名user" column="关联的键" javaType="要射入的对象User"
			
	
	
	一对多关系映射:
		用collenction
		
	一对一:表实体包含主表实体的对象引用
	一对多 :实体类加入一个对象集合
		示例：用户和账户
		
			一个用户可以有多个账户
			一个账户只能属于一个用户（多个账户也可以属于同一个用户）
		步骤：
			1、建立两张表：用户表，账户表
				Account表通过uid与user中id外键关联
				让用户表和账户表之间具备一对多的关系：需要使用外键在账户表中添加
			2、建立两个实体类：用户实体类和账户实体类
				让用户和账户的实体类能体现出来一对多的关系
			3、建立两个配置文件
				用户的配置文件
				账户的配置文件
			4、实现配置：
				当我们查询用户时，可以同时得到用户下所包含的账户信息
				当我们查询账户时，可以同时得到账户的所属用户信息

		示例：用户和角色
		实体类为什么要实现Serializable?
			一个用户可以有多个角色
			一个角色可以赋予多个用户
		步骤：
			1、建立两张表：用户表，角色表
				让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。
			2、建立两个实体类：用户实体类和角色实体类
				让用户和角色的实体类能体现出来多对多的关系
				各自包含对方一个集合引用
			3、建立两个配置文件
				用户的配置文件
				角色的配置文件
			4、实现配置：
				当我们查询用户时，可以同时得到用户所包含的角色信息
				当我们查询角色时，可以同时得到角色的所赋予的用户信息
				